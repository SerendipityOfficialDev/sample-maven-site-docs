<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JavaDocAdvanced.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sample-maven-site</a> &gt; <a href="index.source.html" class="el_package">it.serendigity.samples.advanced</a> &gt; <span class="el_source">JavaDocAdvanced.java</span></div><h1>JavaDocAdvanced.java</h1><pre class="source lang-java linenums">
package it.serendigity.samples.advanced;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.Proxy;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.net.URLStreamHandlerFactory;
import java.util.Collection;

/**
 * Class {@code URL} represents a Uniform Resource
 * Locator, a pointer to a &quot;resource&quot; on the World
 * Wide Web. A resource can be something as simple as a file or a
 * directory, or it can be a reference to a more complicated object,
 * such as a query to a database or to a search engine. More
 * information on the types of URLs and their formats can be found at:
 * &lt;a href=
 * &quot;http://web.archive.org/web/20051219043731/http://archive.ncsa.uiuc.edu/SDG/Software/Mosaic/Demo/url-primer.html&quot;&gt;
 * &lt;i&gt;Types of URL&lt;/i&gt;&lt;/a&gt;
 * &lt;p&gt;
 * In general, a URL can be broken into several parts. Consider the
 * following example:
 * &lt;blockquote&gt;
 *
 * &lt;pre&gt;
 *     http://www.example.com/docs/resource1.html
 * &lt;/pre&gt;
 *
 * &lt;/blockquote&gt;
 * &lt;p&gt; The URL above indicates that the protocol to use is
 * {@code http} (HyperText Transfer Protocol) and that the
 * information resides on a host machine named
 * {@code www.example.com}. The information on that host
 * machine is named {@code /docs/resource1.html}. The exact
 * meaning of this name on the host machine is both protocol
 * dependent and host dependent. The information normally resides in
 * a file, but it could be generated on the fly. This component of
 * the URL is called the &lt;i&gt;path&lt;/i&gt; component.
 * &lt;p&gt;
 * A URL can optionally specify a &quot;port&quot;, which is the
 * port number to which the TCP connection is made on the remote host
 * machine. If the port is not specified, the default port for
 * the protocol is used instead. For example, the default port for
 * {@code http} is {@code 80}. An alternative port could be
 * specified as:
 * &lt;blockquote&gt;
 *
 * &lt;pre&gt;
 *     http://www.example.com:1080/docs/resource1.html
 * &lt;/pre&gt;
 *
 * &lt;/blockquote&gt;
 * &lt;p&gt;
 * The syntax of {@code URL} is defined by &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2396: Uniform
 * Resource Identifiers (URI): Generic Syntax&lt;/i&gt;&lt;/a&gt;, amended by &lt;a
 * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2732: Format for
 * Literal IPv6 Addresses in URLs&lt;/i&gt;&lt;/a&gt;. The Literal IPv6 address format
 * also supports scope_ids. The syntax and usage of scope_ids is described
 * &lt;a href=&quot;Inet6Address.html#scoped&quot;&gt;here&lt;/a&gt;.
 * &lt;p&gt;
 * A URL may have appended to it a &quot;fragment&quot;, also known
 * as a &quot;ref&quot; or a &quot;reference&quot;. The fragment is indicated by the sharp
 * sign character &quot;#&quot; followed by more characters. For example,
 * &lt;blockquote&gt;
 *
 * &lt;pre&gt;
 *     http://java.sun.com/index.html#chapter1
 * &lt;/pre&gt;
 *
 * &lt;/blockquote&gt;
 * &lt;p&gt;
 * This fragment is not technically part of the URL. Rather, it
 * indicates that after the specified resource is retrieved, the
 * application is specifically interested in that part of the
 * document that has the tag {@code chapter1} attached to it. The
 * meaning of a tag is resource specific.
 * &lt;p&gt;
 * An application can also specify a &quot;relative URL&quot;,
 * which contains only enough information to reach the resource
 * relative to another URL. Relative URLs are frequently used within
 * HTML pages. For example, if the contents of the URL:
 * &lt;blockquote&gt;
 *
 * &lt;pre&gt;
 *     http://java.sun.com/index.html
 * &lt;/pre&gt;
 *
 * &lt;/blockquote&gt;
 * contained within it the relative URL:
 * &lt;blockquote&gt;
 *
 * &lt;pre&gt;
 * FAQ.html
 * &lt;/pre&gt;
 *
 * &lt;/blockquote&gt;
 * it would be a shorthand for:
 * &lt;blockquote&gt;
 *
 * &lt;pre&gt;
 *     http://java.sun.com/FAQ.html
 * &lt;/pre&gt;
 *
 * &lt;/blockquote&gt;
 * &lt;p&gt;
 * The relative URL need not specify all the components of a URL. If
 * the protocol, host name, or port number is missing, the value is
 * inherited from the fully specified URL. The file component must be
 * specified. The optional fragment is not inherited.
 * &lt;p&gt;
 * The URL class does not itself encode or decode any URL components
 * according to the escaping mechanism defined in RFC2396. It is the
 * responsibility of the caller to encode any fields, which need to be
 * escaped prior to calling URL, and also to decode any escaped fields,
 * that are returned from URL. Furthermore, because URL has no knowledge
 * of URL escaping, it does not recognise equivalence between the encoded
 * or decoded form of the same URL. For example, the two URLs:
 *
 * &lt;pre&gt;
 *     http://foo.com/hello world/ and http://foo.com/hello%20world
 * &lt;/pre&gt;
 *
 * would be considered not equal to each other.
 * &lt;p&gt;
 * Note, the {@link java.net.URI} class does perform escaping of its
 * component fields in certain circumstances. The recommended way
 * to manage the encoding and decoding of URLs is to use {@link java.net.URI},
 * and to convert between these two classes using {@link #toURI()} and
 * {@link URI#toURL()}.
 * &lt;p&gt;
 * The {@link java.net.URLEncoder} and {@link java.net.URLDecoder} classes can also be
 * used, but only for HTML form encoding, which is not the same
 * as the encoding scheme defined in RFC2396.
 *
 * @author James Gosling
 * @since JDK1.0
 */
public final class JavaDocAdvanced implements java.io.Serializable {

	static final String BUILTIN_HANDLERS_PREFIX = &quot;sun.net.www.protocol&quot;;
	static final long serialVersionUID = -7627629688361524110L;

	/**
	 * The property which specifies the package prefix list to be scanned
	 * for protocol handlers. The value of this property (if any) should
	 * be a vertical bar delimited list of package names to search through
	 * for a protocol handler to load. The policy of this class is that
	 * all protocol handlers will be in a class called &lt;protocolname&gt;.Handler,
	 * and each package in the list is examined in turn for a matching
	 * handler. If none are found (or the property is not specified), the
	 * default package prefix, sun.net.www.protocol, is used. The search
	 * proceeds from the first package in the list to the last and stops
	 * when a match is found.
	 */
	private static final String protocolPathProp = &quot;java.protocol.handler.pkgs&quot;;



	/**
	 * Creates a {@code URL} object from the specified
	 * {@code protocol}, {@code host}, {@code port}
	 * number, and {@code file}.
	 * &lt;p&gt;
	 * {@code host} can be expressed as a host name or a literal
	 * IP address. If IPv6 literal address is used, it should be
	 * enclosed in square brackets ({@code '['} and {@code ']'}), as
	 * specified by &lt;a
	 * href=&quot;http://www.ietf.org/rfc/rfc2732.txt&quot;&gt;RFC&amp;nbsp;2732&lt;/a&gt;;
	 * However, the literal IPv6 address format defined in &lt;a
	 * href=&quot;http://www.ietf.org/rfc/rfc2373.txt&quot;&gt;&lt;i&gt;RFC&amp;nbsp;2373: IP
	 * Version 6 Addressing Architecture&lt;/i&gt;&lt;/a&gt; is also accepted.
	 * &lt;p&gt;
	 * Specifying a {@code port} number of {@code -1}
	 * indicates that the URL should use the default port for the
	 * protocol.
	 * &lt;p&gt;
	 * If this is the first URL object being created with the specified
	 * protocol, a &lt;i&gt;stream protocol handler&lt;/i&gt; object, an instance of
	 * class {@code URLStreamHandler}, is created for that protocol:
	 * &lt;ol&gt;
	 * &lt;li&gt;If the application has previously set up an instance of
	 * {@code URLStreamHandlerFactory} as the stream handler factory,
	 * then the {@code createURLStreamHandler} method of that instance
	 * is called with the protocol string as an argument to create the
	 * stream protocol handler.&lt;/li&gt;
	 * &lt;li&gt;If no {@code URLStreamHandlerFactory} has yet been set up,
	 * or if the factory's {@code createURLStreamHandler} method
	 * returns {@code null}, then the constructor finds the
	 * value of the system property:&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * &lt;pre&gt;
	 * java.protocol.handler.pkgs
	 * &lt;/pre&gt;
	 *
	 * If the value of that system property is not {@code null},
	 * it is interpreted as a list of packages separated by a vertical
	 * slash character '{@code |}'. The constructor tries to load
	 * the class named:
	 *
	 * &lt;pre&gt;
	 *         &amp;lt;&lt;i&gt;package&lt;/i&gt;&amp;gt;.&amp;lt;&lt;i&gt;protocol&lt;/i&gt;&amp;gt;.Handler
	 * &lt;/pre&gt;
	 *
	 * where &amp;lt;&lt;i&gt;package&lt;/i&gt;&amp;gt; is replaced by the name of the package
	 * and &amp;lt;&lt;i&gt;protocol&lt;/i&gt;&amp;gt; is replaced by the name of the protocol.
	 * If this class does not exist, or if the class exists but it is not
	 * a subclass of {@code URLStreamHandler}, then the next package
	 * in the list is tried.
	 * &lt;ol&gt;
	 * &lt;li&gt;If the previous step fails to find a protocol handler, then the
	 * constructor tries to load from a system default package.&lt;/li&gt;
	 * &lt;/ol&gt;
	 * If this class does not exist, or if the class exists but it is not a
	 * subclass of {@code URLStreamHandler}, then a
	 * {@code MalformedURLException} is thrown.
	 * &lt;p&gt;
	 * Protocol handlers for the following protocols are guaranteed
	 * to exist on the search path :-
	 * &lt;blockquote&gt;
	 *
	 * &lt;pre&gt;
	 *     http, https, file, and jar
	 * &lt;/pre&gt;
	 *
	 * &lt;/blockquote&gt;
	 * Protocol handlers for additional protocols may also be
	 * available.
	 * &lt;p&gt;
	 * No validation of the inputs is performed by this constructor.
	 *
	 * @param protocol the name of the protocol to use.
	 * @param host the name of the host.
	 * @param port the port number on the host.
	 * @param file the file on the host
	 * @exception MalformedURLException if an unknown protocol is specified.
	 * @see System#getProperty(java.lang.String)
	 * #setURLStreamHandlerFactory(
	 * java.net.URLStreamHandlerFactory)
	 * @see java.net.URLStreamHandler
	 * @see java.net.URLStreamHandlerFactory#createURLStreamHandler(
	 * java.lang.String)
	 */
	public JavaDocAdvanced( String protocol, String host, int port, String file )
			throws MalformedURLException {
<span class="nc" id="L252">		this( protocol, host, port, file, null );</span>
<span class="nc" id="L253">	}</span>

	/**
	 * Creates a URL from the specified {@code protocol}
	 * name, {@code host} name, and {@code file} name. The
	 * default port for the specified protocol is used.
	 * &lt;p&gt;
	 * This method is equivalent to calling the four-argument
	 * constructor with the arguments being {@code protocol},
	 * {@code host}, {@code -1}, and {@code file}.
	 * No validation of the inputs is performed by this constructor.
	 *
	 * @param protocol the name of the protocol to use.
	 * @param host the name of the host.
	 * @param file the file on the host.
	 * @exception MalformedURLException if an unknown protocol is specified.
	 * int, java.lang.String)
	 */
	public JavaDocAdvanced( String protocol, String host, String file )
			throws MalformedURLException {
<span class="nc" id="L273">		this( protocol, host, -1, file );</span>
<span class="nc" id="L274">	}</span>

	/**
	 * Creates a {@code URL} object from the specified
	 * {@code protocol}, {@code host}, {@code port}
	 * number, {@code file}, and {@code handler}. Specifying
	 * a {@code port} number of {@code -1} indicates that
	 * the URL should use the default port for the protocol. Specifying
	 * a {@code handler} of {@code null} indicates that the URL
	 * should use a default stream handler for the protocol, as outlined
	 * for:
	 * java.net.URL#URL(java.lang.String, java.lang.String, int,
	 * java.lang.String)
	 * &lt;p&gt;
	 * If the handler is not null and there is a security manager,
	 * the security manager's {@code checkPermission}
	 * method is called with a
	 * {@code NetPermission(&quot;specifyStreamHandler&quot;)} permission.
	 * This may result in a SecurityException.
	 * No validation of the inputs is performed by this constructor.
	 *
	 * @param protocol the name of the protocol to use.
	 * @param host the name of the host.
	 * @param port the port number on the host.
	 * @param file the file on the host
	 * @param handler the stream handler for the URL.
	 * @exception MalformedURLException if an unknown protocol is specified.
	 * @exception SecurityException
	 * if a security manager exists and its
	 * {@code checkPermission} method doesn't allow
	 * specifying a stream handler explicitly.
	 * @see java.lang.System#getProperty(java.lang.String)
	 * #setURLStreamHandlerFactory(
	 * java.net.URLStreamHandlerFactory)
	 * @see java.net.URLStreamHandlerFactory#createURLStreamHandler(
	 * java.lang.String)
	 * @see SecurityManager#checkPermission
	 * @see java.net.NetPermission
	 */
	public JavaDocAdvanced( String protocol,
			String host,
			int port,
			String file,
<span class="nc" id="L317">			URLStreamHandler handler ) throws MalformedURLException {</span>

<span class="nc" id="L319">	}</span>

	/**
	 * Creates a {@code URL} object from the {@code String}
	 * representation.
	 * &lt;p&gt;
	 * This constructor is equivalent to a call to the two-argument
	 * constructor with a {@code null} first argument.
	 *
	 * @param spec the {@code String} to parse as a URL.
	 * @exception MalformedURLException if no protocol is specified, or an
	 * unknown protocol is found, or {@code spec} is {@code null}.
	 */
	public JavaDocAdvanced( String spec ) throws MalformedURLException {
<span class="nc" id="L333">		this( null, spec );</span>
<span class="nc" id="L334">	}</span>

	/**
	 * Creates a URL by parsing the given spec within a specified context.
	 * The new URL is created from the given context URL and the spec
	 * argument as described in
	 * RFC2396 &amp;quot;Uniform Resource Identifiers : Generic * Syntax&amp;quot; :
	 * &lt;blockquote&gt;
	 *
	 * &lt;pre&gt;
	 *          &amp;lt;scheme&amp;gt;://&amp;lt;authority&amp;gt;&amp;lt;path&amp;gt;?&amp;lt;query&amp;gt;#&amp;lt;fragment&amp;gt;
	 * &lt;/pre&gt;
	 *
	 * &lt;/blockquote&gt;
	 * The reference is parsed into the scheme, authority, path, query and
	 * fragment parts. If the path component is empty and the scheme,
	 * authority, and query components are undefined, then the new URL is a
	 * reference to the current document. Otherwise, the fragment and query
	 * parts present in the spec are used in the new URL.
	 * &lt;p&gt;
	 * If the scheme component is defined in the given spec and does not match
	 * the scheme of the context, then the new URL is created as an absolute
	 * URL based on the spec alone. Otherwise the scheme component is inherited
	 * from the context URL.
	 * &lt;p&gt;
	 * If the authority component is present in the spec then the spec is
	 * treated as absolute and the spec authority and path will replace the
	 * context authority and path. If the authority component is absent in the
	 * spec then the authority of the new URL will be inherited from the
	 * context.
	 * &lt;p&gt;
	 * If the spec's path component begins with a slash character
	 * &amp;quot;/&amp;quot; then the
	 * path is treated as absolute and the spec path replaces the context path.
	 * &lt;p&gt;
	 * Otherwise, the path is treated as a relative path and is appended to the
	 * context path, as described in RFC2396. Also, in this case,
	 * the path is canonicalized through the removal of directory
	 * changes made by occurrences of &amp;quot;..&amp;quot; and &amp;quot;.&amp;quot;.
	 * &lt;p&gt;
	 * For a more detailed description of URL parsing, refer to RFC2396.
	 *
	 * @param context the context in which to parse the specification.
	 * @param spec the {@code String} to parse as a URL.
	 * @exception MalformedURLException if no protocol is specified, or an
	 * unknown protocol is found, or {@code spec} is {@code null}.
	 * @see java.net.URLStreamHandler
	 * @see java.net.URLStreamHandler#parseURL
	 */
	public JavaDocAdvanced( JavaDocAdvanced context, String spec ) throws MalformedURLException {
<span class="nc" id="L384">		this( context, spec, null );</span>
<span class="nc" id="L385">	}</span>

	/**
	 * Creates a URL by parsing the given spec with the specified handler
	 * within a specified context. If the handler is null, the parsing
	 * occurs as with the two argument constructor.
	 *
	 * @param context the context in which to parse the specification.
	 * @param spec the {@code String} to parse as a URL.
	 * @param handler the stream handler for the URL.
	 * @exception MalformedURLException if no protocol is specified, or an
	 * unknown protocol is found, or {@code spec} is {@code null}.
	 * @exception SecurityException
	 * if a security manager exists and its
	 * {@code checkPermission} method doesn't allow
	 * specifying a stream handler.
	 * @see java.net.URLStreamHandler
	 * @see java.net.URLStreamHandler#parseURL
	 */
	public JavaDocAdvanced( JavaDocAdvanced context, String spec, URLStreamHandler handler )
<span class="nc" id="L405">			throws MalformedURLException {</span>

<span class="nc" id="L407">	}</span>

	/**
	 * Sets the fields of the URL. This is not a public method so that
	 * only URLStreamHandlers can modify URL fields. URLs are
	 * otherwise constant.
	 *
	 * @param protocol the name of the protocol to use
	 * @param host the name of the host
	 * @param port the port number on the host
	 * @param file the file on the host
	 * @param ref the internal reference in the URL
	 */
	void set( String protocol, String host, int port,
			String file, String ref ) {

<span class="nc" id="L423">	}</span>



	/**
	 * Compares this URL for equality with another object.
	 * &lt;p&gt;
	 * If the given object is not a URL then this method immediately returns
	 * {@code false}.
	 * &lt;p&gt;
	 * Two URL objects are equal if they have the same protocol, reference
	 * equivalent hosts, have the same port number on the host, and the same
	 * file and fragment of the file.
	 * &lt;p&gt;
	 * Two hosts are considered equivalent if both host names can be resolved
	 * into the same IP addresses; else if either host name can't be
	 * resolved, the host names must be equal without regard to case; or both
	 * host names equal to null.
	 * &lt;p&gt;
	 * Since hosts comparison requires name resolution, this operation is a
	 * blocking operation.
	 * &lt;p&gt;
	 * Note: The defined behavior for {@code equals} is known to
	 * be inconsistent with virtual hosting in HTTP.
	 *
	 * @param obj the URL to compare against.
	 * @return {@code true} if the objects are the same;
	 * {@code false} otherwise.
	 */
	public boolean equals( Object obj ) {
<span class="nc" id="L453">		return false;</span>
	}

	/**
	 * Creates an integer suitable for hash table indexing.
	 * &lt;p&gt;
	 * The hash code is based upon all the URL components relevant for URL
	 * comparison. As such, this operation is a blocking operation.
	 * &lt;p&gt;
	 *
	 * @return a hash code for this {@code URL}.
	 */
	public synchronized int hashCode() {
<span class="nc" id="L466">		return 0;</span>
	}

	/**
	 * Compares two URLs, excluding the fragment component.
	 * &lt;p&gt;
	 * Returns {@code true} if this {@code URL} and the
	 * {@code other} argument are equal without taking the
	 * fragment component into consideration.
	 *
	 * @param other the {@code URL} to compare against.
	 * @return {@code true} if they reference the same remote object;
	 * {@code false} otherwise.
	 */
	public boolean sameFile( JavaDocAdvanced other ) {
<span class="nc" id="L481">		return false;</span>
	}

	/**
	 * Constructs a string representation of this {@code URL}. The
	 * string is created by calling the {@code toExternalForm}
	 * method of the stream protocol handler for this object.
	 *
	 * @return a string representation of this object.
	 * @see java.net.URLStreamHandler#toExternalForm
	 */
	public String toString() {
<span class="nc" id="L493">		return toExternalForm();</span>
	}

	/**
	 * Constructs a string representation of this {@code URL}. The
	 * string is created by calling the {@code toExternalForm}
	 * method of the stream protocol handler for this object.
	 *
	 * @return a string representation of this object.
	 * @see java.net.URLStreamHandler#toExternalForm
	 */
	public String toExternalForm() {
<span class="nc" id="L505">		return null;</span>
	}

	/**
	 * Returns a {@link java.net.URI} equivalent to this URL.
	 * This method functions in the same way as {@code new URI (this.toString())}.
	 * &lt;p&gt;
	 * Note, any URL instance that complies with RFC 2396 can be converted
	 * to a URI. However, some URLs that are not strictly in compliance
	 * can not be converted to a URI.
	 *
	 * @exception URISyntaxException if this URL is not formatted strictly according to
	 * to RFC2396 and cannot be converted to a URI.
	 * @return a URI instance equivalent to this URL.
	 * @since 1.5
	 */
	public URI toURI() throws URISyntaxException {
<span class="nc" id="L522">		return new URI( toString() );</span>
	}

	/**
	 * Returns a {@link java.net.URLConnection URLConnection} instance that
	 * represents a connection to the remote object referred to by the
	 * {@code URL}.
	 * &lt;P&gt;
	 * A new instance of {@linkplain java.net.URLConnection URLConnection} is
	 * created every time when invoking the
	 * {@linkplain java.net.URLStreamHandler#openConnection}
	 * URLStreamHandler.openConnection(URL)} method of the protocol handler for
	 * this URL.
	 * &lt;/P&gt;
	 * &lt;P&gt;
	 * It should be noted that a URLConnection instance does not establish
	 * the actual network connection on creation. This will happen only when
	 * calling {@linkplain java.net.URLConnection#connect() URLConnection.connect()}.
	 * &lt;/P&gt;
	 * &lt;P&gt;
	 * If for the URL's protocol (such as HTTP or JAR), there
	 * exists a public, specialized URLConnection subclass belonging
	 * to one of the following packages or one of their subpackages:
	 * java.lang, java.io, java.util, java.net, the connection
	 * returned will be of that subclass. For example, for HTTP an
	 * HttpURLConnection will be returned, and for JAR a
	 * JarURLConnection will be returned.
	 * &lt;/P&gt;
	 *
	 * @return a {@link java.net.URLConnection URLConnection} linking
	 * to the URL.
	 * @exception IOException if an I/O exception occurs.
	 */
	public URLConnection openConnection() throws java.io.IOException {
<span class="nc" id="L556">		return null;</span>
	}

	/**
	 * Same as {@link #openConnection()}, except that the connection will be
	 * made through the specified proxy; Protocol handlers that do not
	 * support proxing will ignore the proxy parameter and make a
	 * normal connection.
	 * Invoking this method preempts the system's default ProxySelector
	 * settings.
	 *
	 * @param proxy the Proxy through which this connection
	 * will be made. If direct connection is desired,
	 * Proxy.NO_PROXY should be specified.
	 * @return a {@code URLConnection} to the URL.
	 * @exception IOException if an I/O exception occurs.
	 * @exception SecurityException if a security manager is present
	 * and the caller doesn't have permission to connect
	 * to the proxy.
	 * @exception IllegalArgumentException will be thrown if proxy is null,
	 * or proxy has the wrong type
	 * @exception UnsupportedOperationException if the subclass that
	 * implements the protocol handler doesn't support
	 * this method.
	 * @see java.net.URLConnection
	 * @see java.net.URLStreamHandler#openConnection
	 * @since 1.5
	 */
	public URLConnection openConnection( Proxy proxy )
			throws java.io.IOException {
<span class="nc" id="L586">		return null;</span>
	}

	/**
	 * Opens a connection to this {@code URL} and returns an
	 * {@code InputStream} for reading from that connection. This
	 * method is a shorthand for:
	 * &lt;blockquote&gt;
	 *
	 * &lt;pre&gt;
	 * openConnection().getInputStream()
	 * &lt;/pre&gt;
	 *
	 * &lt;/blockquote&gt;
	 *
	 * @return an input stream for reading from the URL connection.
	 * @exception IOException if an I/O exception occurs.
	 * #openConnection()
	 * @see java.net.URLConnection#getInputStream()
	 */
	public final InputStream openStream() throws java.io.IOException {
<span class="nc" id="L607">		return null;</span>
	}

	/**
	 * Gets the contents of this URL. This method is a shorthand for:
	 * &lt;blockquote&gt;
	 *
	 * &lt;pre&gt;
	 * openConnection().getContent()
	 * &lt;/pre&gt;
	 *
	 * &lt;/blockquote&gt;
	 *
	 * @return the contents of this URL.
	 * @exception IOException if an I/O exception occurs.
	 * @see java.net.URLConnection#getContent()
	 */
	public final Object getContent() throws java.io.IOException {
<span class="nc" id="L625">		return openConnection().getContent();</span>
	}

	/**
	 * Gets the contents of this URL. This method is a shorthand for:
	 * &lt;blockquote&gt;
	 *
	 * &lt;pre&gt;
	 *     openConnection().getContent(Class[])
	 * &lt;/pre&gt;
	 *
	 * &lt;/blockquote&gt;
	 *
	 * @param classes an array of Java types
	 * @return the content object of this URL that is the first match of
	 * the types specified in the classes array.
	 * null if none of the requested types are supported.
	 * @exception IOException if an I/O exception occurs.
	 * @see java.net.URLConnection#getContent(Class[])
	 * @since 1.3
	 */
	public final Object getContent( Class[] classes )
			throws java.io.IOException {
<span class="nc" id="L648">		return null;</span>
	}

	/**
	 * The URLStreamHandler factory.
	 */
	static URLStreamHandlerFactory factory;

	/**
	 * Sets an application's {@code URLStreamHandlerFactory}.
	 * This method can be called at most once in a given Java Virtual
	 * Machine.
	 * &lt;p&gt;
	 * The {@code URLStreamHandlerFactory} instance is used to
	 * construct a stream protocol handler from a protocol name.
	 * &lt;p&gt;
	 * If there is a security manager, this method first calls
	 * the security manager's {@code checkSetFactory} method
	 * to ensure the operation is allowed.
	 * This could result in a SecurityException.
	 *
	 * @param fac the desired factory.
	 * @exception Error if the application has already set a factory.
	 * @exception SecurityException if a security manager exists and its
	 * {@code checkSetFactory} method doesn't allow
	 * the operation.
	 * @see java.net.URLStreamHandlerFactory
	 * @see SecurityManager#checkSetFactory
	 */
	public static void setURLStreamHandlerFactory( URLStreamHandlerFactory fac ) {

<span class="nc" id="L679">	}</span>

	/**
	 * Returns the Stream Handler.
	 *
	 * @param protocol the protocol to use
	 */
	static URLStreamHandler getURLStreamHandler( String protocol ) {

<span class="nc" id="L688">		return null;</span>

	}

	/**
	 * WriteObject is called to save the state of the URL to an
	 * ObjectOutputStream. The handler is not saved since it is
	 * specific to this system.
	 *
	 * @serialData the default write object value. When read back in,
	 * the reader must ensure that calling getURLStreamHandler with
	 * the protocol variable returns a valid URLStreamHandler and
	 * throw an IOException if it does not.
	 * @param s - parameter
	 * @throws IOException IOException if it does not.
	 */
	private synchronized void writeObject( java.io.ObjectOutputStream s )
			throws IOException {
<span class="nc" id="L706">		s.defaultWriteObject(); // write the fields</span>
<span class="nc" id="L707">	}</span>

	/**
	 * Test generics
	 *
	 * @param &lt;T&gt; generic type of collections
	 * @param a the array to convert
	 * @param c the collection
	 */
	public static &lt;T&gt; void fromArrayToCollection( T[] a, Collection&lt;T&gt; c ) {
<span class="nc bnc" id="L717" title="All 2 branches missed.">		for ( T o : a ) {</span>
<span class="nc" id="L718">			c.add( o );</span>
		}
<span class="nc" id="L720">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>